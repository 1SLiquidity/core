- What tokens (+chain) are avaialble. And where do we pull this token data from?

- The Keeper and UI can be a single repo yea? Since the only work the keeper is doing is pulling data from DEXs and processing that data for the UI.
Will be seperate codebases but sure can be a single repo for organizational purposes

- Why does dex data need to be cached? Whats the purpose of Redis here? 
To help with scalability so the same data isnt being queried for all users all the time, rather its cached, depending on the type of data its cache time varies.

- Tech stack for Keeper
Use serverless and serverless-offline npm. Docker for running redis locally. Can test serverless locally, then to aws dev/staging/prod. Which deploys AWS lambda functions, API Gateway endpoints, iam, env variables

serverless executions but can add cron job layer as well that utilizies aws eventbridges for periodic executions. What kind of functionalities will the cron job handle? cache cleanup?

- How many DEXs will the keeper try to index?

- Can each portion of a stream be settled across any DEXs? yes.

- Is a portion of the stream always executed when its created? yes.

- Why is StreamDaemon caching last timestamp of sweet spot?
For gas efficiency

- Explain instasettle? user opts in for insta settle and thats why they pay fees
- Stream settlements across dexes happens individually yea?
- is sweet spot recalcualted throughout trade execution? yes

- in notes, it mentions keeper is a cronjob or async lamda calls? KeeperClient specs discussion regarding updating smart-contract, holidng EOA's keys, websockets to monitor dex data

- utilise websockets to monitor DEX dynamics and trigger updates to the subgraoh **asynchronously**
Isnt the subgraph listeneing to blockchain events? how does the keeper populate the subgraph

- what is the subgraph layer here? is it for data permanence and queryability over just the redis cached data?


//

DEX WebSocket -> Keeper Lambda -> Redis Cache -> TimescaleDB (mk2)
Client Request -> API Gateway -> Lambda -> Redis Cache/TimescaleDB -> Response

Backend:
Runtime: Node.js (TypeScript)
Serverless Framework: AWS Lambda
WebSocket Handling: AWS API Gateway WebSocket API
Scheduling: AWS EventBridge (for cron jobs)

Data Storage:
Real-time Cache: Redis
Recent prices
Active orders
Temporary calculations

Historical Data: TimescaleDB
Price history
Trade history
Volume data